<html>
<head>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: #1a1a1a;
      font-family: 'Arial', sans-serif;
    }
    canvas { 
      touch-action: none; 
      width: 100%; 
      height: 100%; 
    }

    /* Betting Panel Styles */
    #betting-panel {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(20, 20, 30, 0.95);
      border: 2px solid rgba(255, 215, 0, 0.6);
      border-radius: 12px;
      padding: 20px;
      min-width: 280px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    #betting-panel.hidden {
      opacity: 0;
      pointer-events: none;
      transform: translateY(-20px);
    }

    .panel-title {
      font-size: 20px;
      font-weight: bold;
      color: #FFD700;
      text-align: center;
      margin-bottom: 15px;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 12px 0;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 6px;
      border-left: 3px solid #FFD700;
    }

    .stat-label {
      color: #AAA;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .stat-value {
      color: #FFD700;
      font-size: 18px;
      font-weight: bold;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
    }

    .bet-input-container {
      margin-top: 20px;
      padding-top: 15px;
      border-top: 1px solid rgba(255, 215, 0, 0.3);
    }

    .bet-input-label {
      color: #CCC;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 8px;
      display: block;
    }

    #bet-input {
      width: 100%;
      padding: 12px;
      background: rgba(0, 0, 0, 0.4);
      border: 2px solid rgba(255, 215, 0, 0.4);
      border-radius: 6px;
      color: #FFD700;
      font-size: 16px;
      font-weight: bold;
      text-align: center;
      outline: none;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }

    #bet-input:focus {
      border-color: #FFD700;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
    }

    #bet-input::placeholder {
      color: rgba(255, 215, 0, 0.4);
    }

    .button-row {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }

    .bet-button {
      flex: 1;
      padding: 10px;
      background: linear-gradient(135deg, #FFD700, #FFA500);
      border: none;
      border-radius: 6px;
      color: #000;
      font-weight: bold;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .bet-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
    }

    .bet-button:active {
      transform: translateY(0);
    }

    /* HSE Display Styles */
    #hse-display {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(20, 20, 30, 0.95);
      border: 2px solid rgba(100, 200, 255, 0.6);
      border-radius: 12px;
      padding: 20px 30px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
    }

    .hse-label {
      color: #6CC;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 8px;
      text-align: center;
    }

    .hse-value {
      color: #00D4FF;
      font-size: 48px;
      font-weight: bold;
      text-align: center;
      text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
      font-family: 'Courier New', monospace;
      letter-spacing: 3px;
    }

    /* Toggle hint */
    .toggle-hint {
      position: absolute;
      top: 20px;
      left: 20px;
      color: rgba(255, 255, 255, 0.5);
      font-size: 12px;
      background: rgba(0, 0, 0, 0.5);
      padding: 8px 12px;
      border-radius: 6px;
      letter-spacing: 1px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <!-- Betting Panel -->
  <div id="betting-panel">
    <div class="panel-title">Betting</div>
    
    <div class="stat-row">
      <span class="stat-label">Pot</span>
      <span class="stat-value" id="pot-value">$500</span>
    </div>
    
    <div class="stat-row">
      <span class="stat-label">Your Balance</span>
      <span class="stat-value" id="balance-value">$10,000</span>
    </div>
    
    <div class="bet-input-container">
      <label class="bet-input-label">Bet Amount</label>
      <input type="number" id="bet-input" placeholder="Enter amount..." min="0" step="10">
      
      <div class="button-row">
        <button class="bet-button" onclick="app.quickBet(50)">+50</button>
        <button class="bet-button" onclick="app.quickBet(100)">+100</button>
        <button class="bet-button" onclick="app.quickBet(500)">+500</button>
      </div>
      
      <div class="button-row" style="margin-top: 8px;">
        <button class="bet-button" onclick="app.placeBet()">Bet</button>
        <button class="bet-button" style="background: linear-gradient(135deg, #FF4444, #CC0000);" onclick="app.fold()">Fold</button>
      </div>
    </div>
  </div>

  <!-- HSE Display -->
  <div id="hse-display">
    <div class="hse-label">Hand Strength</div>
    <div class="hse-value" id="hse-value">0.00</div>
  </div>

  <!-- Toggle Hint -->
  <div class="toggle-hint">Press 'B' to toggle betting panel</div>

  <script src="https://unpkg.com/filament@1.9.0/filament.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/3.4.3/gl-matrix-min.js"></script>
  <script>
      // --- Poker Hand Evaluator ---
    function evaluateHand(userCards, communityCards) {
        const ranks = {"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"10":10,"J":11,"Q":12,"K":13,"A":14};
        const suits = {"D":0,"S":1,"H":2,"C":3};
        
        const allCards = userCards.concat(communityCards);
        const rankCounts = {};
        const suitCounts = [0,0,0,0];
        
        for (let card of allCards) {
            let r = card.slice(0, -1);
            let s = card.slice(-1);
            rankCounts[r] = (rankCounts[r] || 0) + 1;
            suitCounts[suits[s]]++;
        }
        
        const flush = suitCounts.some(c => c >= 5);
        
        let pairs = 0, triples = 0, quads = 0;
        for (let r in rankCounts) {
            if (rankCounts[r] === 2) pairs++;
            if (rankCounts[r] === 3) triples++;
            if (rankCounts[r] === 4) quads++;
        }

        let highCard = Math.max(...allCards.map(c => ranks[c.slice(0, -1)]));
        
        let score = 0;
        if (quads) score = 0.95;
        else if (triples && pairs) score = 0.9;
        else if (flush) score = 0.85;
        else if (triples) score = 0.7;
        else if (pairs >= 2) score = 0.6;
        else if (pairs === 1) score = 0.4;
        else score = highCard/14 * 0.3 + 0.1;

        return score;
    }

    const ibl_url = 'https://raw.githubusercontent.com/BlakeLeviSmith/Poker-3D-assets/main/myenv_ibl.ktx';
    const sky_url = 'https://raw.githubusercontent.com/BlakeLeviSmith/Poker-3D-assets/main/myenv_skybox.ktx';

    Filament.init([ibl_url, sky_url], () => {
      window.VertexAttribute = Filament.VertexAttribute
      window.AttributeType = Filament.VertexBuffer$AttributeType;
      window.PrimitiveType = Filament.RenderableManager$PrimitiveType
      window.IndexType = Filament.IndexBuffer$IndexType
      window.Fov = Filament.Camera$Fov
      window.LightType = Filament.LightManager$Type

      const canvas = document.getElementById('canvas')
      const dpr = 2.5
      canvas.width = window.innerWidth * dpr
      canvas.height = window.innerHeight * dpr
      window.app = new App(canvas)
    })

    let balance = 10000;
    let pot = 500;

    function updateUI() {
      document.getElementById("balance-value").textContent = "$" + balance.toLocaleString();
      document.getElementById("pot-value").textContent = "$" + pot.toLocaleString();
    }

    class App {
      constructor(canvas) {
        this.canAct = false; // player cannot bet/fold yet
        this.revealStage = 0; // 0 = nothing revealed

        this.canvas = canvas
        this.engine = Filament.Engine.create(canvas)
        this.scene = this.engine.createScene()
        this.tm = null

        // Scene state
        this.sceneLoaded = false
        this.playerCount = 2
        this.deck = []
        
        // Card dealing animation state
        this.animCount = 0
        this.animFb = -2.2937662601470947
        this.animLr = -0.21454206109046936
        this.animUpDown = 0.3555052876472473
        
        // User cards
        this.userDeckIndex = 0
        this.userCard1 = null
        this.userCard2 = null
        this.userCardDealComplete = false
        this.userDealtAll = false
        this.card1Up = false
        this.card2Up = false
        this.time1 = 0
        this.time2 = 0
        
        // Opponent cards
        this.opponentDeckIndex = 2
        this.opponentCardDealComplete = false
        this.opponentDealtCount = 0
        this.allOpponentsDealt = false
        
        // River cards
        this.riverDeckIndex = this.playerCount * 2
        this.riverDealtCount = 0
        this.riverCards = []
        this.riverFlipped = false

        // Entities
        this.cardEntities = []
        this.cardVisibility = []
        this.deckEntities = []
        this.playerEntities = []
        
        this.cardMappings = {
          'AD': '0', '2D': '1', '3D': '2', '4D': '3', '5D': '4', '6D': '5', '7D': '6', '8D': '7', '9D': '8', '10D': '9', 'JD': '10', 'QD': '11', 'KD': '12',
          'AS': '13', '2S': '14', '3S': '15', '4S': '16', '5S': '17', '6S': '18', '7S': '19', '8S': '20', '9S': '21', '10S': '22', 'JS': '23', 'QS': '24', 'KS': '25',
          'AH': '26', '2H': '27', '3H': '28', '4H': '29', '5H': '30', '6H': '31', '7H': '32', '8H': '33', '9H': '34', '10H': '35', 'JH': '36', 'QH': '37', 'KH': '38',
          'AC': '39', '2C': '40', '3C': '41', '4C': '42', '5C': '43', '6C': '44', '7C': '45', '8C': '46', '9C': '47', '10C': '48', 'JC': '49', 'QC': '50', 'KC': '51'
        }

        this.ksInitialTransform = null

        this.setupRenderer()
        this.loadAssets()
        this.setupCameraControls()
        this.setupKeyboardControls()

        this.render = this.render.bind(this)
        this.resize = this.resize.bind(this)
        window.addEventListener('resize', this.resize)

        window.requestAnimationFrame(this.render)
      }

      setupRenderer() {
        const indirectLight = this.engine.createIblFromKtx(ibl_url)
        indirectLight.setIntensity(80000)
        this.scene.setIndirectLight(indirectLight)

        const skybox = this.engine.createSkyFromKtx(sky_url)
        this.scene.setSkybox(skybox)

        this.swapChain = this.engine.createSwapChain()
        this.renderer = this.engine.createRenderer()
        this.camera = this.engine.createCamera(Filament.EntityManager.get().create())
        this.view = this.engine.createView()
        this.view.setCamera(this.camera)
        this.view.setScene(this.scene)
        this.view.setViewport([0, 0, this.canvas.width, this.canvas.height])
        this.view.setAntiAliasing(Filament.View$AntiAliasing.FXAA)
        this.view.setSampleCount(8)
        this.view.setPostProcessingEnabled(false)

        this.camera.setProjectionFov(45, this.canvas.width / this.canvas.height, 0.1, 100.0, Fov.VERTICAL)
      }

      async loadAssets() {
        this.tm = this.engine.getTransformManager()
        
        await this.loadScene()
        await this.loadDeck()
        await this.loadCards()
        await this.loadPlayers()
        await this.loadChips()
        
        this.deck = this.getShuffledDeck()
        this.sceneLoaded = true
      }

      async loadScene() {
        const response = await fetch("https://raw.githubusercontent.com/BlakeLeviSmith/Poker-3D-assets/main/Scene.glb")
        const data = await response.arrayBuffer()
        const loader = this.engine.createAssetLoader()
        const asset = loader.createAssetFromBinary(new Uint8Array(data))
        asset.loadResources()
        await new Promise(resolve => setTimeout(resolve, 500))

        const entities = asset.getEntities()
        for (let i = 0; i < entities.length; i++) {
          this.scene.addEntity(entities[i])
        }
      }

      async loadDeck() {
        const response = await fetch('https://raw.githubusercontent.com/BlakeLeviSmith/Poker-3D-assets/main/Deck.glb')
        const data = await response.arrayBuffer()
        const loader = this.engine.createAssetLoader()
        const asset = loader.createAssetFromBinary(new Uint8Array(data))
        asset.loadResources()
        await new Promise(resolve => setTimeout(resolve, 500))

        this.deckEntities = asset.getEntities()
        for (let i = 0; i < this.deckEntities.length; i++) {
          this.scene.addEntity(this.deckEntities[i])
        }

        // Position deck
        const deckEntity = this.deckEntities[0]
        const deckInst = this.tm.getInstance(deckEntity)
        const deckTranslation = new Float32Array([
          1, 0, 0, 0,
          0, 1, 0, 0,
          0, 0, 1, 0,
          -1.85, 0.0, -0.15, 1
        ])

        const currentTransform = this.tm.getTransform(deckInst)
        const newTransform = this.multiplyMatrices(deckTranslation, currentTransform)
        this.tm.setTransform(deckInst, newTransform)
      }

      async loadChips(){
        const response = await fetch('https://raw.githubusercontent.com/BlakeLeviSmith/Poker-3D-assets/main/Chips.glb')
        const data = await response.arrayBuffer()
        const loader = this.engine.createAssetLoader()
        const asset = loader.createAssetFromBinary(new Uint8Array(data))
        asset.loadResources()
        await new Promise(resolve => setTimeout(resolve, 500))

        this.chipEntities = asset.getEntities()
        for (let i = 0; i < this.chipEntities.length; i++) {
          this.scene.addEntity(this.chipEntities[i])
        }


        //UserChips
        let entity = this.chipEntities[0]
        let inst = this.tm.getInstance(entity)
        let currentTransform = this.tm.getTransform(inst)
        let newTransform = new Float32Array(currentTransform)
        
        newTransform[12] = -1.4
        newTransform[13] = 0.2
        newTransform[14] = 0.1
        
        this.tm.setTransform(inst, newTransform)


        //Oppononet Two chips
        if (this.playerCount >= 3){
          entity = this.chipEntities[102]
          inst = this.tm.getInstance(entity)
          currentTransform = this.tm.getTransform(inst)
          newTransform = new Float32Array(currentTransform)
          
          newTransform[12] = -1.7
          newTransform[13] = 0.2
          newTransform[14] = 0.38
          
          this.tm.setTransform(inst, newTransform)
        }


        //Opponenet One Chips
        entity = this.chipEntities[204]
        inst = this.tm.getInstance(entity)
        currentTransform = this.tm.getTransform(inst)
        newTransform = new Float32Array(currentTransform)
        
        newTransform[12] = -1.3
        newTransform[13] = 0.2
        newTransform[14] = 0.38
        
        this.tm.setTransform(inst, newTransform)
          

        //Opponenet Three Chips
        if (this.playerCount >= 4){
          entity = this.chipEntities[306]
          inst = this.tm.getInstance(entity)
          currentTransform = this.tm.getTransform(inst)
          newTransform = new Float32Array(currentTransform)
          
          newTransform[12] = -2.15
          newTransform[13] = 0.2
          newTransform[14] = 0.18
          
          this.tm.setTransform(inst, newTransform)
        }


        //Opponenet Four Chips
        if (this.playerCount >= 5){
          entity = this.chipEntities[408]
          inst = this.tm.getInstance(entity)
          currentTransform = this.tm.getTransform(inst)
          newTransform = new Float32Array(currentTransform)
          
          newTransform[12] = -2.15
          newTransform[13] = 0.2
          newTransform[14] = -0.15
          
          this.tm.setTransform(inst, newTransform)
        }


        //Opponenet Five Chips
        if (this.playerCount >= 6){
          entity = this.chipEntities[510]
          inst = this.tm.getInstance(entity)
          currentTransform = this.tm.getTransform(inst)
          newTransform = new Float32Array(currentTransform)
          
          newTransform[12] = -2.15
          newTransform[13] = 0.2
          newTransform[14] = -0.265
          
          this.tm.setTransform(inst, newTransform)
        }
          

        //Opponenet Six Chips
        if (this.playerCount >= 7){
          entity = this.chipEntities[612]
          inst = this.tm.getInstance(entity)
          currentTransform = this.tm.getTransform(inst)
          newTransform = new Float32Array(currentTransform)
          
          newTransform[12] = -2.15
          newTransform[13] = 0.2
          newTransform[14] = -0.615
          
          this.tm.setTransform(inst, newTransform)
        }
          

        //Opponenet Seven Chips
        if (this.playerCount >= 8){
          entity = this.chipEntities[714]
          inst = this.tm.getInstance(entity)
          currentTransform = this.tm.getTransform(inst)
          newTransform = new Float32Array(currentTransform)
          
          newTransform[12] = -1.3
          newTransform[13] = 0.2
          newTransform[14] = -0.76
          
          this.tm.setTransform(inst, newTransform)
        }


        //Opponenet Eight Chips
        if (this.playerCount == 9){
          entity = this.chipEntities[816]
          inst = this.tm.getInstance(entity)
          currentTransform = this.tm.getTransform(inst)
          newTransform = new Float32Array(currentTransform)
          
          newTransform[12] = -1.7
          newTransform[13] = 0.2
          newTransform[14] = -0.76
          
          this.tm.setTransform(inst, newTransform)
        }
      }
    

      async loadCards() {
        const response = await fetch("https://raw.githubusercontent.com/BlakeLeviSmith/Poker-3D-assets/main/CardDeck.glb")
        const data = await response.arrayBuffer()
        const loader = this.engine.createAssetLoader()
        const asset = loader.createAssetFromBinary(new Uint8Array(data))
        asset.loadResources()
        await new Promise(resolve => setTimeout(resolve, 500))

        this.cardEntities = asset.getEntities()
        this.cardVisibility = new Array(this.cardEntities.length).fill(true)

        for (let i = 0; i < this.cardEntities.length; i++) {
          this.scene.addEntity(this.cardEntities[i])
        }

        // Position all cards to deck location
        const cardTranslation = new Float32Array([
          1, 0, 0, 0,
          0, 1, 0, 0,
          0, 0, 1, 0,
          -1.85, 0.167, -0.266, 1
        ])

        // Get reference card (KS) transform
        const ksIndex = parseInt(this.cardMappings['KS'])
        const ksEntity = this.cardEntities[ksIndex]
        const ksInst = this.tm.getInstance(ksEntity)
        const ksCurrentTransform = this.tm.getTransform(ksInst)
        const ksTransform = this.multiplyMatrices(cardTranslation, ksCurrentTransform)
        
        this.ksInitialTransform = new Float32Array(ksTransform)
        
        const ksWorldX = ksTransform[12]
        const ksWorldY = ksTransform[13]
        const ksWorldZ = ksTransform[14]

        // Apply same transform to all cards
        for (let i = 0; i < this.cardEntities.length; i++) {
          const entity = this.cardEntities[i]
          const inst = this.tm.getInstance(entity)
          const currentTransform = this.tm.getTransform(inst)
          const newTransform = this.multiplyMatrices(cardTranslation, currentTransform)
          
          this.tm.setTransform(inst, newTransform)
          this.moveCardWorld(entity, ksWorldX, ksWorldY, ksWorldZ)
        }

        // Hide all cards except one for testing
        const unhiddenCard = this.cardMappings['3S']
        this.hideAllCards()
        this.showCard(unhiddenCard)
      }

      async loadPlayers() {
        const response = await fetch("https://raw.githubusercontent.com/BlakeLeviSmith/Poker-3D-assets/main/Player.glb")
        const data = await response.arrayBuffer()
        const loader = this.engine.createAssetLoader()
        const asset = loader.createAssetFromBinary(new Uint8Array(data))
        asset.loadResources()
        await new Promise(resolve => setTimeout(resolve, 500))

        this.playerEntities = asset.getEntities()
        for (let i = 0; i < this.playerEntities.length; i++) {
          this.scene.addEntity(this.playerEntities[i])
        }

        // User Placment
        for (let i = 7; i < 11; i++) {
          const entity = this.playerEntities[i]
          const inst = this.tm.getInstance(entity)
          const currentTransform = this.tm.getTransform(inst)
          const newTransform = new Float32Array(currentTransform)
          
          newTransform[12] = -0.8
          newTransform[13] = 0.13
          newTransform[14] = -0.23
          
          this.tm.setTransform(inst, newTransform)
        }

        // Opponent 3 Placment
        if (this.playerCount >= 4){
          for (let i = 0; i < 7; i++) {
            const entity = this.playerEntities[i]
            const inst = this.tm.getInstance(entity)
            const currentTransform = this.tm.getTransform(inst)
            const newTransform = new Float32Array(currentTransform)
            
            newTransform[12] = -2.7
            newTransform[13] = 0.13
            newTransform[14] = 0.45
            
            this.tm.setTransform(inst, newTransform)
          }
        }

        // Opponenet 4 Placment
        if (this.playerCount >= 5){
          for (let i = 11; i < 18; i++) {
            const entity = this.playerEntities[i]
            const inst = this.tm.getInstance(entity)
            const currentTransform = this.tm.getTransform(inst)
            const newTransform = new Float32Array(currentTransform)
            
            newTransform[12] = -2.7
            newTransform[13] = 0.13
            newTransform[14] = 0.0
            
            this.tm.setTransform(inst, newTransform)
          }
        }

        // Opponenet 5 Placment
        if (this.playerCount >= 6){
          for (let i = 18; i < 25; i++) {
            const entity = this.playerEntities[i]
            const inst = this.tm.getInstance(entity)
            const currentTransform = this.tm.getTransform(inst)
            const newTransform = new Float32Array(currentTransform)
            
            newTransform[12] = -2.7
            newTransform[13] = 0.13
            newTransform[14] = -0.45
            
            this.tm.setTransform(inst, newTransform)
          }
        }

        // Opponenet 6 Placment
        if (this.playerCount >= 7){
          for (let i = 25; i < 32; i++) {
            const entity = this.playerEntities[i]
            const inst = this.tm.getInstance(entity)
            const currentTransform = this.tm.getTransform(inst)
            const newTransform = new Float32Array(currentTransform)
            
            newTransform[12] = -2.7
            newTransform[13] = 0.13
            newTransform[14] = -0.9
            
            this.tm.setTransform(inst, newTransform)
          }
        }

        // Opponenet 1 Placment
        for (let i = 32; i < 39; i++) {
          const entity = this.playerEntities[i]
          const inst = this.tm.getInstance(entity)
          const currentTransform = this.tm.getTransform(inst)
          const newTransform = new Float32Array(currentTransform)
          
          newTransform[12] = -1.7
          newTransform[13] = 0.13
          newTransform[14] = 0.6
          
          this.tm.setTransform(inst, newTransform)
        }

        // Opponenet 7 Placment
        if (this.playerCount >= 8){
          for (let i = 39; i < 46; i++) {
            const entity = this.playerEntities[i]
            const inst = this.tm.getInstance(entity)
            const currentTransform = this.tm.getTransform(inst)
            const newTransform = new Float32Array(currentTransform)
            
            newTransform[12] = -2.15
            newTransform[13] = 0.13
            newTransform[14] = -1.1
            
            this.tm.setTransform(inst, newTransform)
          }
        }

        // Opponenet 8 Placment
        if (this.playerCount == 9){
          for (let i = 46; i < 53; i++) {
            const entity = this.playerEntities[i]
            const inst = this.tm.getInstance(entity)
            const currentTransform = this.tm.getTransform(inst)
            const newTransform = new Float32Array(currentTransform)
            
            newTransform[12] = -1.7
            newTransform[13] = 0.13
            newTransform[14] = -1.1
            
            this.tm.setTransform(inst, newTransform)
          }
        }

        // Opponenet 2 Placment
        if (this.playerCount >= 3){
          for (let i = 53; i < 60; i++) {
            const entity = this.playerEntities[i]
            const inst = this.tm.getInstance(entity)
            const currentTransform = this.tm.getTransform(inst)
            const newTransform = new Float32Array(currentTransform)
            
            newTransform[12] = -2.15
            newTransform[13] = 0.13
            newTransform[14] = 0.6
            
            this.tm.setTransform(inst, newTransform)
          }
        }


        this.toggleArm(1)
      }

      multiplyMatrices(a, b) {
        const result = new Float32Array(16)
        for (let row = 0; row < 4; row++) {
          for (let col = 0; col < 4; col++) {
            let sum = 0
            for (let k = 0; k < 4; k++) {
              sum += a[k * 4 + row] * b[col * 4 + k]
            }
            result[col * 4 + row] = sum
          }
        }
        return result
      }

      hideAllCards() {
        for (let i = 0; i < this.cardEntities.length; i++) {
          this.scene.remove(this.cardEntities[i])
          this.cardVisibility[i] = false
        }
      }

      hideCard(index) {
        if (this.cardVisibility[index]) {
          this.scene.remove(this.cardEntities[index])
          this.cardVisibility[index] = false
        }
      }

      toggleArm(postion){
        if (postion == 1){
          this.scene.remove(this.playerEntities[10])
          this.scene.addEntity(this.playerEntities[7])
        }
        if (postion == 2){
          this.scene.remove(this.playerEntities[7])
          this.scene.addEntity(this.playerEntities[10])
        }
      }

      showCard(index) {
        if (!this.cardVisibility[index]) {
          this.scene.addEntity(this.cardEntities[index])
          this.cardVisibility[index] = true
        }
      }

      getShuffledDeck() {
        const keys = Object.keys(this.cardMappings)
        
        // Fisher–Yates shuffle
        for (let i = keys.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [keys[i], keys[j]] = [keys[j], keys[i]]
        }
        console.log(keys)
        return keys
      }

      setupCameraControls() {
        this.isDragging = false
        this.lastX = 0
        this.lastY = 0
        
        this.fixedEye = [-0.5, 0.65, -0.1]
        this.initialCenter = [-1, 0.55, 0]
        
        const initialDir = [
          this.initialCenter[0] - this.fixedEye[0],
          this.initialCenter[1] - this.fixedEye[1],
          this.initialCenter[2] - this.fixedEye[2]
        ]
        
        const horizontalDist = Math.sqrt(initialDir[0] * initialDir[0] + initialDir[2] * initialDir[2])
        this.yaw = Math.atan2(initialDir[0], -initialDir[2])
        this.pitch = Math.atan2(initialDir[1], horizontalDist)
        
        this.maxPitch = Math.PI / 3
        this.maxYaw = Math.PI / 2
        
        this.initialYaw = this.yaw
        this.initialPitch = this.pitch
        
        this.up = [0, 1, 0]
        this.camera.lookAt(this.fixedEye, this.initialCenter, this.up)

        document.addEventListener("mousedown", e => {
          this.isDragging = true
          this.lastX = e.clientX
          this.lastY = e.clientY
        })

        document.addEventListener("mousemove", e => {
          if (!this.isDragging) return

          const deltaX = e.clientX - this.lastX
          const deltaY = e.clientY - this.lastY
          const sensitivity = 0.003

          this.yaw -= deltaX * sensitivity
          this.pitch -= deltaY * sensitivity
          
          this.yaw = Math.max(this.initialYaw - this.maxYaw, Math.min(this.initialYaw + this.maxYaw, this.yaw))
          this.pitch = Math.max(this.initialPitch - this.maxPitch, Math.min(this.initialPitch + this.maxPitch, this.pitch))
          
          const lookDir = [
            Math.cos(this.pitch) * Math.sin(this.yaw),
            Math.sin(this.pitch),
            -Math.cos(this.pitch) * Math.cos(this.yaw)
          ]
          
          const center = [
            this.fixedEye[0] + lookDir[0],
            this.fixedEye[1] + lookDir[1],
            this.fixedEye[2] + lookDir[2]
          ]
          
          this.camera.lookAt(this.fixedEye, center, this.up)

          this.lastX = e.clientX
          this.lastY = e.clientY
        })

        document.addEventListener("mouseup", () => {
          this.isDragging = false
        })
      }

      setupKeyboardControls() {
        document.addEventListener("keydown", (e) => {
          if (e.key === "q") {
            if (!this.card2Up) {
              this.revealUserCard(this.userCard2, this.time2, 1)
              this.time2++
              this.card2Up = true
            } else {
              this.placeCardBack(this.userCard2, 1)
              this.card2Up = false
            }
          }

          if (e.key === "w") {
            if (!this.card1Up) {
              this.revealUserCard(this.userCard1, this.time1, 2)
              this.time1++
              this.card1Up = true
            } else {
              this.placeCardBack(this.userCard1, 2)
              this.card1Up = false
            }
          }

          if (event.key.toLowerCase() === "b") {
            const panel = document.getElementById("betting-panel");
            panel.classList.toggle("hidden");
          }
        })
      }

      resetAnimationState() {
        this.animCount = 0
        this.animFb = -2.2937662601470947
        this.animUpDown = 0.3555052876472473
        this.animLr = -0.21454206109046936
      }

      animateCardDeal(cardNum, phase) {
        const transform = new Float32Array(this.ksInitialTransform)
        
        transform[12] = this.animFb
        transform[13] = this.animUpDown
        transform[14] = this.animLr

        this.animCount++
        
        if (this.animCount > 25) {
          this.resetAnimationState()
          return { transform, complete: true }
        }

        // Calculate movement based on phase
        switch(phase) {
          case 'user':
            this.animFb += (0.43 / 25)
            this.animLr += (cardNum / 625)
            this.animUpDown += (-0.045 / 25)
            break
            
          case 'opponent1':
            this.animFb += ((0.3 - cardNum / 25) / 25)
            this.animLr += (0.6 / 25)
            this.animUpDown += ((-0.045 + cardNum / 500) / 25)
            break
            
          case 'opponent2':
            this.animFb += ((-0.02 - cardNum / 25) / 25)
            this.animLr += (0.6 / 25)
            this.animUpDown += ((-0.045 + cardNum / 500) / 25)
            break
            
          case 'opponent3':
            this.animFb += (-0.38 / 25)
            this.animLr += ((0.75 - cardNum / 25) / 25)
            this.animUpDown += ((-0.045 + cardNum / 500) / 25)
            break
            
          case 'opponent4':
            this.animFb += (-0.38 / 25)
            this.animLr += ((0.473332 - cardNum / 25) / 25)
            this.animUpDown += ((-0.045 + cardNum / 500) / 25)
            break
            
          case 'opponent5':
            this.animFb += (-0.38 / 25)
            this.animLr += ((0.196666 - cardNum / 25) / 25)
            this.animUpDown += ((-0.045 + cardNum / 500) / 25)
            break
            
          case 'opponent6':
            this.animFb += (-0.38 / 25)
            this.animLr += ((-0.08 - cardNum / 25) / 25)
            this.animUpDown += ((-0.045 + cardNum / 500) / 25)
            break
            
          case 'opponent7':
            this.animFb += ((-0.6 + cardNum / 25) / 25)
            this.animLr += (-0.5 / 25)
            this.animUpDown += ((-0.045 + cardNum / 500) / 25)
            break
            
          case 'opponent8':
            this.animFb += ((-0.2 + cardNum / 25) / 25)
            this.animLr += (-0.5 / 25)
            this.animUpDown += ((-0.045 + cardNum / 500) / 25)
            break
            
          case 'river':
            this.animFb += (0.1 / 25)
            this.animLr += ((0.2 - cardNum / 10) / 25)
            this.animUpDown += ((-0.045 + cardNum / 500) / 25)
            break
        }
        
        return { transform, complete: false }
      }

      cardSpin(entity, axis, angle = Math.PI / 2) {
        const instance = this.tm.getInstance(entity)
        const currentTransform = this.tm.getTransform(instance)

        const cos = Math.cos(angle)
        const sin = Math.sin(angle)
        
        let rotation
        if (axis === "x") {
          rotation = new Float32Array([
            1, 0, 0, 0,
            0, cos, -sin, 0,
            0, sin, cos, 0,
            0, 0, 0, 1
          ])
        } else if (axis === "y") {
          rotation = new Float32Array([
            cos, 0, -sin, 0,
            0, 1, 0, 0,
            sin, 0, cos, 0,
            0, 0, 0, 1
          ])
        } else if (axis === "z") {
          rotation = new Float32Array([
            cos, -sin, 0, 0,
            sin, cos, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
          ])
        }

        const result = this.multiplyMatrices(currentTransform, rotation)
        this.tm.setTransform(instance, result)
      }

      moveCardWorld(entity, worldX, worldY, worldZ) {
        const instance = this.tm.getInstance(entity)
        const currentTransform = this.tm.getTransform(instance)

        const newTransform = new Float32Array(16)
        for (let row = 0; row < 3; row++) {
          for (let col = 0; col < 3; col++) {
            newTransform[col * 4 + row] = currentTransform[col * 4 + row]
          }
        }
        newTransform[3] = newTransform[7] = newTransform[11] = 0
        newTransform[12] = worldX
        newTransform[13] = worldY
        newTransform[14] = worldZ
        newTransform[15] = 1

        this.tm.setTransform(instance, newTransform)
      }

      revealUserCard(cardEntity, time, cardNum) {
        const xPos = -0.64
        const yPos = 0.48
        const zPos = cardNum === 1 ? 0.825 : 0.775

        if (time === 0) {
          this.cardSpin(cardEntity, "x")
          this.cardSpin(cardEntity, "z", Math.PI / 2)
        } else {
          this.cardSpin(cardEntity, "x")
        }
        
        this.moveCardWorld(cardEntity, xPos, yPos, zPos)
      }

      placeCardBack(cardEntity, cardNum) {
        const zPos = cardNum === 1 ? 0.8 : 0.75
        this.cardSpin(cardEntity, "x", -Math.PI / 2)
        this.moveCardWorld(cardEntity, -1.2, 0.35, zPos)
      }

      dealUserCards() {
        if (this.userCardDealComplete) {
          if (this.userDeckIndex >= 1) {
            this.userDealtAll = true
            return
          }
          this.userCardDealComplete = false
          this.userDeckIndex++
        }
        
        const cardIndex = parseInt(this.cardMappings[this.deck[this.userDeckIndex]])
        const cardEntity = this.cardEntities[cardIndex]
        
        if (this.userDeckIndex === 0) {
          this.userCard1 = cardEntity
        } else if (this.userDeckIndex === 1) {
          this.userCard2 = cardEntity
        }
        
        this.showCard(cardIndex)
        
        const { transform, complete } = this.animateCardDeal(-1 + this.userDeckIndex, 'user')
        const instance = this.tm.getInstance(cardEntity)
        this.tm.setTransform(instance, transform)
        
        if (complete) {
          this.userCardDealComplete = true
        }
      }

      dealOpponentCards() {
        if (!this.userDealtAll) return
        
        if (this.opponentCardDealComplete) {
          this.opponentDeckIndex++
          if (this.opponentDeckIndex >= this.playerCount * 2) {
            this.allOpponentsDealt = true
          }
          if (this.allOpponentsDealt && this.userDealtAll) {
            this.canAct = true;     // player can now click Bet or Fold
          }

          this.opponentCardDealComplete = false
        }

        if (this.allOpponentsDealt) return

        const cardIndex = parseInt(this.cardMappings[this.deck[this.opponentDeckIndex]])
        const cardEntity = this.cardEntities[cardIndex]
        this.showCard(cardIndex)

        let phase
        const personIndex = Math.floor(this.opponentDealtCount)
        
        if (personIndex < 1) phase = 'opponent1'
        else if (personIndex < 2) phase = 'opponent2'
        else if (personIndex < 3) phase = 'opponent3'
        else if (personIndex < 4) phase = 'opponent4'
        else if (personIndex < 5) phase = 'opponent5'
        else if (personIndex < 6) phase = 'opponent6'
        else if (personIndex < 7) phase = 'opponent7'
        else phase = 'opponent8'

        const { transform, complete } = this.animateCardDeal(this.opponentDeckIndex - 2, phase)
        const instance = this.tm.getInstance(cardEntity)
        this.tm.setTransform(instance, transform)
        
        if (complete) {
          this.opponentCardDealComplete = true
          this.opponentDealtCount += 0.5
        }
      }

      dealRiverCards() {
        if (!this.allOpponentsDealt) return
        
        if (this.riverDealtCount < 5) {
          const cardIndex = parseInt(this.cardMappings[this.deck[this.opponentDeckIndex]])
          const cardEntity = this.cardEntities[cardIndex]
          this.showCard(cardIndex)
          
          // Add to river cards array (will have duplicates per frame during animation)
          this.riverCards.push(cardEntity)
          
          const { transform, complete } = this.animateCardDeal(this.opponentDeckIndex - this.playerCount * 2, 'river')
          const instance = this.tm.getInstance(cardEntity)
          this.tm.setTransform(instance, transform)
          
          if (complete) {
            this.opponentCardDealComplete = true
            this.riverDealtCount++
            this.opponentDeckIndex++
            this.opponentCardDealComplete = false
          }
        }
      
      }

      advanceRevealStage() {
        // 0 → pre-flop HSE
        if (this.revealStage === 0) {
            this.updateHSEMonteCarlo();
            this.revealFlop();
            this.revealStage = 1;
            return;
        }

        // 1 → after flop
        if (this.revealStage === 1) {
            this.updateHSEMonteCarlo();
            this.revealTurn();
            this.revealStage = 2;
            return;
        }

        // 2 → after turn
        if (this.revealStage === 2) {
            this.updateHSEMonteCarlo();
            this.revealRiver();
            this.revealStage = 3;
            return;
        }

        // 3 → final HSE after river + final betting round
        if (this.revealStage === 3) {
            this.updateHSEMonteCarlo();  // final HSE
            this.runWinnerCheck();
            this.revealStage = 4; // lock
            return;
        }
      }

      revealFlop() {
        const start = this.playerCount * 2;

        for (let i = 0; i < 3; i++) {
            const cardName = this.deck[start + i];
            const index = parseInt(this.cardMappings[cardName]);
            const entity = this.cardEntities[index];

            // Flip
            this.cardSpin(entity, "x");
            this.cardSpin(entity, "z", Math.PI / 2);

            // Position flop cards
            const zOffset = 0.825 - (i * 0.08);
            this.moveCardWorld(entity, -1.4, 0.3, zOffset);
        }

      }

      revealTurn() {
        const start = this.playerCount * 2;
        const cardName = this.deck[start + 3];
        const index = parseInt(this.cardMappings[cardName]);
        const entity = this.cardEntities[index];

        this.cardSpin(entity, "x");
        this.cardSpin(entity, "z", Math.PI / 2);

        this.moveCardWorld(entity, -1.4, 0.3, 0.825 - 0.24);

      }

      revealRiver() {
        const start = this.playerCount * 2;
        const cardName = this.deck[start + 4];
        const index = parseInt(this.cardMappings[cardName]);
        const entity = this.cardEntities[index];

        this.cardSpin(entity, "x");
        this.cardSpin(entity, "z", Math.PI / 2);

        this.moveCardWorld(entity, -1.4, 0.3, 0.825 - 0.32);

      }



      animationManager() {
        if (!this.sceneLoaded) return
        
        this.dealUserCards()
        this.dealOpponentCards()
        this.dealRiverCards()
        if (this.card1Up || this.card2Up){this.toggleArm(2)}else{this.toggleArm(1)}
      }

      render() {
        this.animationManager()
        this.engine.execute()
        this.renderer.render(this.swapChain, this.view)
        window.requestAnimationFrame(this.render)
      }

      resize() {
        const dpr = 3.0
        const width = this.canvas.width = window.innerWidth * dpr
        const height = this.canvas.height = window.innerHeight * dpr
        this.view.setViewport([0, 0, width, height])
        this.camera.setProjectionFov(75, width / height, 0.1, 100.0, Fov.VERTICAL)
      }

      quickBet(amount) {
        const input = document.getElementById("bet-input");
        const current = parseInt(input.value || "0");
        input.value = current + amount;
      }

      placeBet() {
          if (!this.canAct) {
              alert("Please wait until all cards are dealt.");
              return;
          }

          const input = document.getElementById("bet-input");
          let bet = parseInt(input.value);

          if (isNaN(bet) || bet <= 0) {
            alert("Enter a positive bet amount.");
            return;
          }
          if (bet > balance) {
            alert("You do not have enough balance.");
            return;
          }

          balance -= bet;
          pot += bet;
          input.value = "";
          updateUI();

          this.advanceRevealStage();
      }

      fold() {
        if (!this.canAct) {
            alert("Please wait until all cards are dealt.");
            return;
        }
        this.advanceRevealStage();
      }

      getUserAndBoardCards() {
        const userCards = [this.deck[0], this.deck[1]
        ];

        const communityCards = [
          this.deck[this.playerCount * 2], this.deck[(this.playerCount * 2)+1], this.deck[(this.playerCount * 2)+2], 
          this.deck[(this.playerCount * 2)+3], this.deck[(this.playerCount * 2)+4]
        ];

        return { userCards, communityCards };
      }

      updateHSE() {
        if (!this.userCard1 || !this.userCard2) return;

        const { userCards, communityCards } = this.getUserAndBoardCards();
        const hse = evaluateHand(userCards, communityCards);

        document.getElementById("hse-value").textContent = hse.toFixed(2);
      }

      monteCarloHandStrength(userCards, communityCards, numPlayers = 5, simulations = 1000) {
        let wins = 0;
        let ties = 0;

        const ranks = ["2","3","4","5","6","7","8","9","10","J","Q","K","A"];
        const suits = ["D","S","H","C"];

        // Build remaining deck
        const fullDeck = [];
        for (let r of ranks) {
            for (let s of suits) {
                fullDeck.push(r+s);
            }
        }

        // Remove user and community cards
        const used = new Set([...userCards, ...communityCards]);
        const remainingDeck = fullDeck.filter(c => !used.has(c));

        for (let sim = 0; sim < simulations; sim++) {
            // Shuffle remaining deck
            const deckCopy = [...remainingDeck];
            for (let i = deckCopy.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deckCopy[i], deckCopy[j]] = [deckCopy[j], deckCopy[i]];
            }

            // Complete community cards if not all revealed
            const currentCommunity = [...communityCards];
            while (currentCommunity.length < 5) {
                currentCommunity.push(deckCopy.pop());
            }

            // Deal opponent hands
            const opponents = [];
            for (let p = 0; p < numPlayers - 1; p++) {
                opponents.push([deckCopy.pop(), deckCopy.pop()]);
            }

            const userScore = evaluateHand(userCards, currentCommunity);
            let bestScore = userScore;
            let tieCount = 1;

            for (let opp of opponents) {
                const oppScore = evaluateHand(opp, currentCommunity);
                if (oppScore > bestScore) {
                    bestScore = oppScore;
                    tieCount = 0;
                } else if (oppScore === bestScore) {
                    tieCount++;
                }
            }

            if (bestScore === userScore) {
                if (tieCount === 0) wins++;
                else ties++;
            }
        }

        return {
            winProbability: wins / simulations,
            tieProbability: ties / simulations
        };
    }

      getVisibleCommunityCards() {
      const boardStart = this.playerCount * 2;
      const visible = [];

      for (let i = 0; i < this.riverDealtCount; i++) {
          visible.push(this.deck[boardStart + i]);
      }
      return visible;
    }
    
      updateHSEMonteCarlo() {
        if (!this.userCard1 || !this.userCard2) return;

        const userCards = [this.deck[0], this.deck[1]];
        const communityCards = this.getVisibleCommunityCards();

        // If no board yet, don't calculate
        if (communityCards.length === 0) return;

        // Run 500 simulations (fast)
        const { winProbability, tieProbability } =
            this.monteCarloHandStrength(userCards, communityCards, this.playerCount, 500);

        const hseValue = (winProbability + tieProbability / 2);

        document.getElementById("hse-value").textContent =
            hseValue.toFixed(2);
    }

      runWinnerCheck() {
      const boardStart = this.playerCount * 2;

      const board = [
          this.deck[boardStart],
          this.deck[boardStart + 1],
          this.deck[boardStart + 2],
          this.deck[boardStart + 3],
          this.deck[boardStart + 4]
      ];

      const userHand = [this.deck[0], this.deck[1]];

      let userScore = evaluateHand(userHand, board);
      let bestScore = userScore;
      let winner = "User";

      // Evaluate all opponents
      for (let i = 1; i < this.playerCount; i++) {
          const opp1 = this.deck[i * 2];
          const opp2 = this.deck[i * 2 + 1];
          const oppScore = evaluateHand([opp1, opp2], board);

          if (oppScore > bestScore) {
              bestScore = oppScore;
              winner = "Opponent " + i;
          }
      }

      console.log("Winner:", winner, "with score:", bestScore);
    }


    }
  </script>
</body>
</html>